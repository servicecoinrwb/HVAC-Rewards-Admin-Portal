<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HVAC Rewards Admin Portal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Corrected Ethers.js CDN link -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" xintegrity="sha512-FDc6aAunHk1DRm3w9eNPNXp4BqA0bG8I41u2aT4YpB3zP0pMHHJJoL33QZgTCRgI2E1IxfX5uGv1oXb4PzXgA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #3058A8; /* Custom blue background from image */
        }
        .btn {
            @apply inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all duration-150 ease-in-out;
        }
        .btn:disabled {
            @apply bg-indigo-400 cursor-not-allowed;
        }
        .btn-secondary {
            @apply bg-blue-500 text-white hover:bg-blue-600 focus:ring-blue-400 border-transparent;
        }
        .btn-secondary:disabled {
            @apply bg-blue-400 text-blue-200 cursor-not-allowed;
        }
        .btn-green {
            @apply bg-green-500 hover:bg-green-600 focus:ring-green-400;
        }
        .btn-red {
            @apply bg-red-600 hover:bg-red-700 focus:ring-red-500;
        }
        .input-field {
            @apply block w-full px-3 py-2 bg-blue-700 border border-blue-600 rounded-md text-white placeholder-blue-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm;
        }
        .card {
            background-color: #2B4E99; /* Slightly darker blue for cards */
            @apply border border-blue-700 shadow-lg rounded-lg p-6;
        }
        .table-header {
            @apply px-6 py-3 text-left text-xs font-medium text-blue-200 uppercase tracking-wider;
            background-color: #27478C;
        }
        .table-cell {
            @apply px-6 py-4 whitespace-nowrap text-sm text-gray-200;
        }
        /* Custom scrollbar for better aesthetics in dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #27478C;
        }
        ::-webkit-scrollbar-thumb {
            background: #4f46e5; /* bg-indigo-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #4338ca; /* bg-indigo-700 */
        }
    </style>
</head>
<body class="text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-white">HVAC Rewards Admin Portal</h1>
            <p class="text-lg text-blue-200 mt-2">Manage your on-chain customer loyalty program.</p>
            <div id="connection-status" class="mt-4">
                <button id="connect-wallet" class="btn">Connect Wallet</button>
                <p id="wallet-info" class="hidden text-green-400 font-semibold"></p>
                <p id="wallet-error" class="hidden text-red-400"></p>
            </div>
        </header>

        <main class="space-y-8">
            <!-- Configuration Section -->
            <section id="config-section" class="card">
                <h2 class="text-xl font-semibold mb-4 text-white border-b border-blue-700 pb-2">1. System Configuration</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">
                    <input type="text" id="spn-address" placeholder="SPN Token Address" class="input-field" value="0x29950E3186999F490777f00d97279a62b2dD1818">
                    <input type="text" id="converter-address" placeholder="Converter Address" class="input-field" value="0x524997F5Cf25537a275ad5D0A6A346c733a4fA41">
                    <input type="text" id="staking-address" placeholder="Staking Contract Address" class="input-field" value="0x691e29E98ECDc5ae948355F30102cD4D637eddB7">
                    <input type="text" id="yield-address" placeholder="Yield Contract Address" class="input-field" value="0x71f618EFb0422687e5B2ad9cD973aDACb645D9DE">
                    <input type="text" id="srv-address" placeholder="SRV Token Address" class="input-field">
                    <input type="text" id="srev-address" placeholder="SREV Token Address" class="input-field">
                    <input type="text" id="reward-token-address" placeholder="Reward Token (e.g., USDC) Address" class="input-field">
                </div>
                <p class="text-xs text-blue-300 mt-4">Note: SRV, SREV, and Reward Token addresses will be fetched from contracts if possible.</p>
            </section>

            <!-- Admin Actions Section -->
            <section class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div id="customer-actions" class="card space-y-4">
                    <h2 class="text-xl font-semibold text-white border-b border-blue-700 pb-2">2. Customer Wallet Management</h2>
                    <div>
                        <label for="master-mnemonic" class="block text-sm font-medium text-blue-200">Master Wallet Seed Phrase*</label>
                        <input type="password" id="master-mnemonic" placeholder="Enter 12 or 24-word seed phrase" class="input-field mt-1">
                        <p class="text-xs text-red-400 font-semibold mt-1">SECURITY WARNING: For simulation only. Do not use a real seed phrase with funds.</p>
                    </div>

                    <div class="pt-4 border-t border-blue-700">
                        <label for="customer-number" class="block text-sm font-medium text-blue-200">Customer Number *</label>
                        <input type="text" id="customer-number" placeholder="e.g., CUST-1001" class="input-field mt-1">
                    </div>
                     <div>
                        <label for="wallet-address" class="block text-sm font-medium text-blue-200">Assign Existing Wallet Address (Optional)</label>
                        <input type="text" id="wallet-address" placeholder="0x... (overrides seed phrase generation)" class="input-field mt-1">
                    </div>
                    <button id="add-customer" class="btn w-full">Add Customer</button>

                    <div class="pt-4 border-t border-blue-700">
                         <h3 class="text-lg font-medium text-white">Issue Points</h3>
                        <label for="spn-amount" class="block text-sm font-medium text-blue-200 mt-2">SPN Amount</label>
                        <input type="number" id="spn-amount" placeholder="e.g., 500" class="input-field mt-1">
                         <p class="text-xs text-blue-300 mt-1">Enter a customer number in the field above to select target.</p>
                        <button id="issue-spn" class="btn btn-green w-full mt-2">Issue SPN to Customer</button>
                    </div>
                </div>
                <div id="system-actions" class="card space-y-4">
                     <h2 class="text-xl font-semibold text-white border-b border-blue-700 pb-2">3. Staking & Yield Management</h2>
                     <div>
                        <label for="fund-amount" class="block text-sm font-medium text-blue-200">Amount to Fund Yield Contract</label>
                        <input type="number" id="fund-amount" placeholder="e.g., 1000" class="input-field mt-1">
                        <button id="fund-yield" class="btn btn-green w-full mt-2">Fund Yield Contract</button>
                    </div>
                </div>
            </section>
            
            <!-- Customer Table Section -->
            <section id="customer-table-section" class="card">
                <div class="flex justify-between items-center border-b border-blue-700 pb-2 mb-4">
                    <h2 class="text-xl font-semibold text-white">4. Customer Dashboard</h2>
                    <button id="refresh-balances" class="btn btn-secondary text-sm">Refresh All</button>
                </div>
                <div class="overflow-x-auto rounded-lg border border-blue-700">
                    <table class="min-w-full divide-y divide-blue-700">
                        <thead>
                            <tr>
                                <th scope="col" class="table-header">Customer #</th>
                                <th scope="col" class="table-header">Wallet Address / Path</th>
                                <th scope="col" class="table-header">SPN</th>
                                <th scope="col" class="table-header">SRV</th>
                                <th scope="col" class="table-header">Staked SRV (SREV)</th>
                                <th scope="col" class="table-header">Pending Yield</th>
                                <th scope="col" class="table-header">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="customer-tbody" class="divide-y divide-blue-700">
                            <!-- Rows will be dynamically inserted here -->
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Log Section -->
            <section id="log-section" class="card">
                <h2 class="text-xl font-semibold mb-4 text-white border-b border-blue-700 pb-2">Activity Log</h2>
                <div id="log-output" class="border rounded-md p-4 h-64 overflow-y-auto text-sm font-mono" style="background-color: #27478C; border-color: #1E40AF;">
                    <p class="text-blue-300">Waiting for actions...</p>
                </div>
            </section>

        </main>
    </div>

    <script>
        // --- PRE-DEFINED ABIs ---
        const spnAbi = [{"inputs":[{"internalType":"address","name":"admin","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"}];
        const converterAbi = [{"inputs":[{"internalType":"address","name":"_spn","type":"address"},{"internalType":"address","name":"_srv","type":"address"},{"internalType":"address","name":"_dao","type":"address"},{"internalType":"uint256","name":"_rate","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"uint256","name":"spnAmount","type":"uint256"}],"name":"burnAndConvert","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"srv","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}];
        const stakingAbi = [{"inputs":[{"internalType":"address","name":"_srv","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"SREV","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SRV","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"stake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"staked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"unstake","outputs":[],"stateMutability":"nonpayable","type":"function"}];
        const yieldAbi = [{"inputs":[{"internalType":"address","name":"_rewardToken","type":"address"},{"internalType":"address","name":"_srevToken","type":"address"},{"internalType":"address","name":"_daoOperator","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"fund","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"viewPending","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"newAPR","type":"uint256"}],"name":"setBaseAPR","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"rewardToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"srevToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}];
        const erc20Abi = [{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}];
        
        let provider, signer, adminAddress;
        let customers = []; // In-memory customer store
        let walletIndex = 0; // Index for deriving wallets from seed

        // --- DOM Elements ---
        const connectButton = document.getElementById('connect-wallet');
        const walletInfo = document.getElementById('wallet-info');
        const walletError = document.getElementById('wallet-error');
        const logOutput = document.getElementById('log-output');

        // --- Utility Functions ---
        function log(message, isError = false) {
            const p = document.createElement('p');
            p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            p.className = isError ? 'text-red-400' : 'text-green-400';

            const firstChild = logOutput.firstChild;
            if (firstChild && firstChild.textContent === 'Waiting for actions...') {
                logOutput.innerHTML = '';
            }
            logOutput.prepend(p);
        }

        async function handleTx(txPromise, successMessage) {
            try {
                log(`Sending transaction...`);
                const tx = await txPromise;
                log(`Transaction sent: ${tx.hash}. Waiting for confirmation...`);
                await tx.wait();
                log(successMessage);
                return true;
            } catch (error) {
                console.error(error);
                log(`Error: ${error.message || error.data?.message || 'Transaction failed.'}`, true);
                return false;
            }
        }

        function getAddress(id) {
            return document.getElementById(id).value;
        }

        function findCustomerByWallet(walletAddress) {
            return customers.find(c => c.walletAddress.toLowerCase() === walletAddress.toLowerCase());
        }

        // --- Customer & Table Management ---
        function addCustomer() {
            const customerNumber = getAddress('customer-number');
            const existingWalletAddress = getAddress('wallet-address');
            const masterMnemonic = getAddress('master-mnemonic');

            if (!customerNumber) {
                log('Customer Number is required.', true);
                return;
            }
            if (customers.find(c => c.customerNumber === customerNumber)) {
                log('Customer number already exists.', true);
                return;
            }

            let newCustomer;

            if (existingWalletAddress) {
                // Use provided wallet address
                if (!ethers.utils.isAddress(existingWalletAddress)) {
                    log('Invalid Ethereum address provided.', true);
                    return;
                }
                newCustomer = {
                    customerNumber: customerNumber,
                    walletAddress: existingWalletAddress,
                    privateKey: null, // No private key for external wallets
                    derivationPath: null,
                    balances: { spn: '0', srv: '0', srev: '0', yield: '0' }
                };
                log(`Added customer ${customerNumber} with existing wallet ${existingWalletAddress}.`);
            } else {
                // Generate a new wallet from the master seed phrase
                if (!masterMnemonic || !ethers.utils.isValidMnemonic(masterMnemonic)) {
                    log('A valid master seed phrase is required to generate a new wallet.', true);
                    return;
                }

                const masterNode = ethers.utils.HDNode.fromMnemonic(masterMnemonic);
                const derivationPath = `m/44'/60'/0'/0/${walletIndex}`;
                const childNode = masterNode.derivePath(derivationPath);
                const wallet = new ethers.Wallet(childNode.privateKey);

                newCustomer = {
                    customerNumber: customerNumber,
                    walletAddress: wallet.address,
                    privateKey: wallet.privateKey, // IMPORTANT: For simulation only.
                    derivationPath: derivationPath,
                    balances: { spn: '0', srv: '0', srev: '0', yield: '0' }
                };
                log(`Generated new wallet for ${customerNumber} at path ${derivationPath}. Address: ${wallet.address}`);
                walletIndex++; // Increment for the next customer
            }
            
            customers.push(newCustomer);
            renderTable();
            document.getElementById('customer-number').value = '';
            document.getElementById('wallet-address').value = '';
        }

        function renderTable() {
            const tbody = document.getElementById('customer-tbody');
            tbody.innerHTML = '';
            if (customers.length === 0) {
                 tbody.innerHTML = `<tr><td colspan="7" class="text-center py-10 text-blue-300">No customers added yet.</td></tr>`;
                 return;
            }
            customers.forEach(customer => {
                const isManaged = !!customer.privateKey;
                const walletDisplay = customer.derivationPath
                    ? `${customer.walletAddress}<br><span class="text-xs text-blue-300">${customer.derivationPath}</span>`
                    : customer.walletAddress;
                
                const row = `
                    <tr class="hover:bg-blue-800">
                        <td class="table-cell font-mono align-top">${customer.customerNumber}</td>
                        <td class="table-cell font-mono text-xs align-top">${walletDisplay}</td>
                        <td class="table-cell align-top" id="spn-${customer.walletAddress}">${customer.balances.spn}</td>
                        <td class="table-cell align-top" id="srv-${customer.walletAddress}">${customer.balances.srv}</td>
                        <td class="table-cell align-top" id="srev-${customer.walletAddress}">${customer.balances.srev}</td>
                        <td class="table-cell font-semibold text-green-400 align-top" id="yield-${customer.walletAddress}">${customer.balances.yield}</td>
                        <td class="table-cell space-x-2 align-top">
                            <button class="btn btn-sm text-xs" onclick="convertAndStake('${customer.walletAddress}')" ${!isManaged ? 'disabled title="Portal can only automate staking for generated wallets."' : ''}>Convert & Stake</button>
                            <button class="btn btn-sm btn-red text-xs" onclick="claimYield('${customer.walletAddress}')" ${!isManaged ? 'disabled title="Portal can only automate claims for generated wallets."' : ''}>Claim Yield</button>
                        </td>
                    </tr>
                `;
                tbody.insertAdjacentHTML('beforeend', row);
            });
        }
        
        // --- Blockchain Interactions ---
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                log('MetaMask is not installed!', true);
                walletError.textContent = 'Please install MetaMask to use this portal.';
                walletError.classList.remove('hidden');
                return;
            }

            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                adminAddress = await signer.getAddress();

                connectButton.classList.add('hidden');
                walletInfo.textContent = `Connected: ${adminAddress.substring(0, 6)}...${adminAddress.substring(adminAddress.length - 4)}`;
                walletInfo.classList.remove('hidden');
                walletError.classList.add('hidden');
                log(`Admin wallet ${adminAddress} connected.`);
                fetchContractAddresses();
            } catch (error) {
                log('Failed to connect wallet.', true);
                walletError.textContent = `Connection failed: ${error.message}`;
                walletError.classList.remove('hidden');
            }
        }
        
        async function fetchContractAddresses() {
            try {
                const converter = new ethers.Contract(getAddress('converter-address'), converterAbi, provider);
                const staking = new ethers.Contract(getAddress('staking-address'), stakingAbi, provider);
                const yieldContract = new ethers.Contract(getAddress('yield-address'), yieldAbi, provider);

                const srvAddr = await converter.srv();
                const srevAddr = await staking.SREV();
                const rewardTokenAddr = await yieldContract.rewardToken();

                document.getElementById('srv-address').value = srvAddr;
                document.getElementById('srev-address').value = srevAddr;
                document.getElementById('reward-token-address').value = rewardTokenAddr;
                log('Fetched dependent contract addresses successfully.');
            } catch (error) {
                log('Could not auto-fetch contract addresses. Please enter them manually.', true);
            }
        }

        async function refreshAllBalances() {
            log('Refreshing all customer balances...');
            for (const customer of customers) {
                await updateAllBalances(customer.walletAddress);
            }
            log('All balances refreshed.');
        }

        async function updateAllBalances(walletAddress) {
            try {
                const spnContract = new ethers.Contract(getAddress('spn-address'), erc20Abi, provider);
                const srvContract = new ethers.Contract(getAddress('srv-address'), erc20Abi, provider);
                const srevContract = new ethers.Contract(getAddress('srev-address'), erc20Abi, provider);
                const yieldContract = new ethers.Contract(getAddress('yield-address'), yieldAbi, provider);

                const [spnBal, srvBal, srevBal, yieldPending, spnDec, srvDec, srevDec, yieldDec] = await Promise.all([
                    spnContract.balanceOf(walletAddress),
                    srvContract.balanceOf(walletAddress),
                    srevContract.balanceOf(walletAddress),
                    yieldContract.viewPending(walletAddress),
                    spnContract.decimals(),
                    srvContract.decimals(),
                    srevContract.decimals(),
                    new ethers.Contract(await yieldContract.rewardToken(), erc20Abi, provider).decimals(),
                ]);

                const customer = findCustomerByWallet(walletAddress);
                if (!customer) return;

                const format = (val, dec) => parseFloat(ethers.utils.formatUnits(val, dec)).toFixed(4);

                customer.balances = {
                    spn: format(spnBal, spnDec),
                    srv: format(srvBal, srvDec),
                    srev: format(srevBal, srevDec),
                    yield: format(yieldPending, yieldDec)
                };
                
                document.getElementById(`spn-${customer.walletAddress}`).textContent = customer.balances.spn;
                document.getElementById(`srv-${customer.walletAddress}`).textContent = customer.balances.srv;
                document.getElementById(`srev-${customer.walletAddress}`).textContent = customer.balances.srev;
                document.getElementById(`yield-${customer.walletAddress}`).textContent = customer.balances.yield;
                
            } catch (error) {
                log(`Failed to update balances for ${walletAddress.substring(0,6)}...: ${error.message}`, true);
            }
        }

        async function issueSpn() {
            if (!signer) { log('Please connect wallet first.', true); return; }
            const customerNumber = getAddress('customer-number');
            const amount = document.getElementById('spn-amount').value;
            if (!customerNumber || !amount) {
                log('Please enter a customer number and SPN amount.', true);
                return;
            }

            const customer = customers.find(c => c.customerNumber === customerNumber);
            if (!customer) {
                log('Customer not found. Please add the customer first.', true);
                return;
            }

            const spnContract = new ethers.Contract(getAddress('spn-address'), spnAbi, signer);
            const decimals = await spnContract.decimals();
            const amountWei = ethers.utils.parseUnits(amount, decimals);
            
            const success = await handleTx(
                spnContract.mint(customer.walletAddress, amountWei),
                `Successfully issued ${amount} SPN to ${customerNumber}.`
            );
            if(success) await updateAllBalances(customer.walletAddress);
        }
        
        async function convertAndStake(walletAddress) {
            if (!provider) { log('Please connect wallet first.', true); return; }
            log(`Starting Convert & Stake process for ${walletAddress.substring(0, 6)}...`);
            const customer = findCustomerByWallet(walletAddress);
            if (!customer) {
                log('Customer not found.', true);
                return;
            }
            if (!customer.privateKey) {
                log('Cannot automate staking for externally provided wallets.', true);
                return;
            }

            const customerSigner = new ethers.Wallet(customer.privateKey, provider);

            const spnContract = new ethers.Contract(getAddress('spn-address'), erc20Abi, customerSigner);
            const srvContract = new ethers.Contract(getAddress('srv-address'), erc20Abi, customerSigner);
            const converterContract = new ethers.Contract(getAddress('converter-address'), converterAbi, customerSigner);
            const stakingContract = new ethers.Contract(getAddress('staking-address'), stakingAbi, customerSigner);
            
            const spnBalance = await spnContract.balanceOf(walletAddress);
            if(spnBalance.isZero()){
                log('Customer has no SPN to convert.', true);
                return;
            }
            log(`Step 1: Approving Converter to spend ${ethers.utils.formatUnits(spnBalance, await spnContract.decimals())} SPN...`);
            let success = await handleTx(
                spnContract.approve(converterContract.address, spnBalance), `SPN approved for Converter.`
            );
            if (!success) return;

            log(`Step 2: Calling burnAndConvert...`);
            success = await handleTx(
                converterContract.burnAndConvert(spnBalance), `SPN converted to SRV.`
            );
            if (!success) return;

            await new Promise(resolve => setTimeout(resolve, 2000));

            const srvBalance = await srvContract.balanceOf(walletAddress);
            if(srvBalance.isZero()){
                log('Conversion resulted in zero SRV. Cannot stake.', true);
                await updateAllBalances(walletAddress);
                return;
            }
            log(`Step 3: Approving Staking contract to spend ${ethers.utils.formatUnits(srvBalance, await srvContract.decimals())} SRV...`);
            success = await handleTx(
                srvContract.approve(stakingContract.address, srvBalance), `SRV approved for Staking.`
            );
            if (!success) return;

            log(`Step 4: Calling stake...`);
            success = await handleTx(
                stakingContract.stake(srvBalance), `SRV staked successfully!`
            );

            if(success) await updateAllBalances(walletAddress);
        }
        
        async function claimYield(walletAddress) {
            if (!provider) { log('Please connect wallet first.', true); return; }
            log(`Claiming yield for ${walletAddress.substring(0, 6)}...`);
            const customer = findCustomerByWallet(walletAddress);
             if (!customer) {
                log('Customer not found.', true);
                return;
            }
            if (!customer.privateKey) {
                log('Cannot automate claims for externally provided wallets.', true);
                return;
            }

            const customerSigner = new ethers.Wallet(customer.privateKey, provider);
            const yieldContract = new ethers.Contract(getAddress('yield-address'), yieldAbi, customerSigner);
            
            log('This action simulates claiming the on-chain yield to the customer wallet after an off-chain payout.');
            const success = await handleTx(
                yieldContract.claim(), `Yield claimed for ${customer.customerNumber}.`
            );

            if(success) await updateAllBalances(walletAddress);
        }

        async function fundYield() {
            if (!signer) { log('Please connect wallet first.', true); return; }
            const amount = document.getElementById('fund-amount').value;
            const rewardTokenAddress = getAddress('reward-token-address');
            const yieldAddress = getAddress('yield-address');
            if (!amount || !rewardTokenAddress || !yieldAddress) {
                log('Please provide fund amount and ensure reward token/yield contract addresses are set.', true);
                return;
            }
            
            const rewardTokenContract = new ethers.Contract(rewardTokenAddress, erc20Abi, signer);
            const yieldContract = new ethers.Contract(yieldAddress, yieldAbi, signer);

            const decimals = await rewardTokenContract.decimals();
            const amountWei = ethers.utils.parseUnits(amount, decimals);
            
            log(`Approving yield contract to spend ${amount} reward tokens...`);
            let success = await handleTx(
                rewardTokenContract.approve(yieldAddress, amountWei), `Approval successful.`
            );
            if (!success) return;
            
            log(`Funding yield contract with ${amount} reward tokens...`);
            await handleTx(
                yieldContract.fund(amountWei), `Yield contract funded successfully.`
            );
        }
        
        // --- Event Listeners ---
        connectButton.addEventListener('click', connectWallet);
        document.getElementById('add-customer').addEventListener('click', addCustomer);
        document.getElementById('issue-spn').addEventListener('click', issueSpn);
        document.getElementById('refresh-balances').addEventListener('click', refreshAllBalances);
        document.getElementById('fund-yield').addEventListener('click', fundYield);

        // --- Initial Load ---
        renderTable();

    </script>
</body>
</html>
